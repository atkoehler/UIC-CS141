/// @file 20240523_LiveSession6.cpp
/// @author Adam T Koehler, PhD
/// @date May 23, 2024
/// @brief Code and lecture notes from the live session. 
///     C++ Concepts: 2D Vector, classes

// Order of the live code from lecture:
// 1. MultiDimVectors()
// 2. Card Class Creation
// 3. Deck Class Creation
// 4. CardDeckExamples()


#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Lecture Parts Prototypes
void MultiDimVectors();
void CardDeckExamples();


/// @brief a Card class to mimic a playing card
class Card
{
    // private data members are only accessible
    // within the class, so in functions defined or declared
    // within the Card class
    private:
        char faceValue;
        string suit;
        bool coloredRed;


    // protected members are available to derived classes
    // we will see this more when we get to inheritance
    protected:


    // public functions provide methods to "users" of our class
    // such as objects created in main. Similar to how we can
    // access the quantity of elements in a vector by invoking
    // .size() but we cannot directly access the variable that
    // stores that numerical value.
    public:
  
        /// @brief Default constructors take no parameters
        ///     When no other constructors exist, a default one is automatically
        ///     generated by the compiler
        Card()
        {
            faceValue = 'Q';
            suit = "clubs";
            coloredRed = true;
        }

        /// @brief fully parameterized constructor for the Card class
        /// @param v the face value of the card
        /// @param s the string representation of card suit
        /// @param coloredRed whether the card is red (true when red, false when not)
        Card(char v, string s, bool coloredRed)
        {
            faceValue = v;
            suit = s;

            // the implicit object needs to be accessed when a paramater
            // variable name overshadows the private data member variable name
            // we use "this" keyword with the arrow operator (->) to utilize the 
            // implictly supplied object's pointer and dereference it
            this->coloredRed = coloredRed;
        }


        // setters/mutators
        // provide public ability to set a data member

        /// @brief set the private data member for face value
        /// @param v 
        void setFaceValue(char v)
        {
            faceValue = v;
        }


        // accessors/getters
        // provide public ability to acquire a data member's value

        // this is our third occurrence of the const keyword
        // the first was directly with local variables or global constants
        // the second was as a constant parameter
        // const'ness must be maintain by any helper function's invoked

        /// @brief acquire the face value of the card
        /// @return the value of the private data member for the card's face value
        char getFaceValue() const
        {
            helper(); // <-- also must be const in its definition

            return faceValue;
        }

        /// @brief acquire the suit value of the card
        /// @return the value of the private data member for the card's suit
        string getSuit() const
        {
            return suit;
        }

        /// @brief is the card a red card?
        /// @return true when the card is a red card, false otherwise
        bool isRed() const
        {
            return coloredRed;
        }
        
        // operators are just functions!
        // the equality operator (==) can be overloaded to our class
        // and then if it is in the public area it can be utilized
        // to compare objects of our class type
        bool operator==(const Card &compare) const
        {
            // we can acquire the private data members directly as we
            // are inside the class. However it is often good practice
            // to utilize the accessors if they are available in case
            // any data member intrepretation is done instead of directly
            // using the value stored by the data member.

            // direct access comparing the object provided via const reference
            // and the implicit object supplied when calling the member function
            // return compare.coloredRed == this->coloredRed &&
            //        compare.suit == this->suit &&
            //        compare.faceValue == this->faceValue;

            // in this example we utilize all the accessor functions instead
            // of directly accessing the data members
            return compare.isRed() == this->isRed() &&
                compare.getSuit() == this->getSuit() &&
                compare.getFaceValue() == this->getFaceValue();
        }


    // we can have more than one area for a class privacy designation
    // the keyword applies to all items after it
    private:

        // helper functions that are used internally by the class are usually
        // not placed in public as they are not meant for public use.
        // This allows us to continuing using our function decomposition skills
        // within the context of class definitions.

        /// @brief helper functions invoked from a const function must also
        ///     be const to maintain the chain of const
        void helper() const {}
};


/// @brief a Deck class to mimic a deck of cards
class Deck
{
    private:
        vector<Card> d;

    public:

    // Function ideas that groups came up with:
    // addCard (insert a Card into the Deck)
    // search for card in the deck (requires operator== in Card)
    // getTop (pull the top card off the deck)
    // drawRandom (pull a random card from the deck)
    // shuffle the deck (the user doesn't need to know the methodology)
    // sort()
    // divideBySuit creating new decks

    /// @brief Acquire the quantity of Cards in the deck.
    /// @return The quantity of Cards in the deck.
    size_t deckSize() const
    {
        return d.size();
    }
};


/// @brief main function for running our examples
/// @param argc the number of command line arguments
/// @param argv the array containing c-strings of command line args
int main(int argc, char *argv[])
{
    if (argc > 1 && isdigit(argv[1][0]))
    {
        // 0 on command line argument means run 2D vector examples
        // 1 on command line argument means run Class & Object examples        
        switch(atoi(argv[1]))
        {
            case 0:
                MultiDimVectors(); 
                break;           

            case 1:
                CardDeckExamples();   
                break;
            
            default:
                break;
        }
    }
    else
    {
        // could not parse or did not find extra command line argument
        // therefore just run everything

        MultiDimVectors();

        cout << endl << endl;

        CardDeckExamples();    
    }

    return 0;
}


/// @brief live code developed for multi dimensional vectors portion 
///     of the live lecture
void MultiDimVectors()
{
    cout << "Explorting 2D Vectors!" << endl;
    cout << "======================" << endl << endl;

    cout << "Let's build a 2D vector from an empty state" << endl;

    // define 2D vector
    vector<vector<int>> gradebook;

    // All of our elements will be grades, maybe a row is a student?
    int grade;

    // We need the number of rows, let's ask the user
    int numStudents;
    cout << "How many rows will our 2D vector have.... aka" << endl;
    cout << "How students will you be entering grades for? ";
    cin >> numStudents;
    cout << endl;
    
    // acquire grades for every student
    for (int i=0; i < numStudents; ++i)
    {
        // build the row element by element   
        cout << "\nEnter grades for student " << i+1 << "." << endl;
        cout << "Grades should be separated by a space and the last grade -1";
        cout << endl;             

        // create a row vector for all the individual student grades
        vector<int> student;

        // We can use a sentinel value to signal the end of our row
        // Since we are taking in "grades" we can use -1 for our sentinel
        do
        {
            cin >> grade;        

            // don't push the sentinel value on to the row
            if (grade != -1)
            {
                student.push_back(grade);
            }
        }while (grade != -1);

        // place the row of student grades into the 2D gradebook vector
        gradebook.push_back(student);
    }


    // Quiz question: 5th row, 3rd column access?
    // gradebook[4][2]

    // We should use at() in C++ unless we need to optimize
    // for extreme efficiency avoiding function call and bounds check.

    // gradebook.at(4);       // resolves to a vector<int>
    // gradebook.at(4).at(2); // resolves to an int
    cout << endl << endl;
    cout << "The second student's third grade is ";
    cout << gradebook.at(1).at(2); // resolves to element
    cout << endl;

    cout << endl << endl;

    // output the entire gradebook using for-each loops
    // use the iomanip library to set the field width of a grade to 5
    // place each student's grade on their own line
    cout << "Here is the entire gradebook: " << endl;
    for(const auto &stud : gradebook)
    {
        for (const auto &gr : stud)
        {
            // use iomanip library setw to set the width of the field
            // that the grade gets output to
            cout << setw(5) << gr << " ";
        }
        cout << endl;
    }
}


/// @brief live code developed for objects and classes portion 
///     of the live lecture
void CardDeckExamples()
{
    cout << "Card & Deck Time!" << endl;
    cout << "=================" << endl << endl;

    cout << "Exploring constructor calls for Card and Deck" << endl;

    // Use the default Card constructor to instantiate three Card objects
    cout << "Creating x, z, and m with the default construtor." << endl;
    Card x;
    Card z;
    Card m;

    // Use the parameterized constructor to instantiate a Card object
    cout << "Creating q with parameterized constructor "
        << " as 'J', \"hearts\", and true" << endl;
    Card q('J', "hearts", true);

    // Create a Deck with default constructor
    cout << "Creating myDeck with the default construtor." << endl;
    Deck myDeck;


    cout << endl << endl;


    // We use the dot operator to access public portions of our Card
    // object similar to how we use the dot operator to call member functions
    // for the vector or string class.
    
    cout << "Exploring accessor function uses." << endl;

    // Invoking the one implemented Deck member function
    cout << "myDeck size is " << myDeck.deckSize() << endl;

    // Output the values from the accessor functions
    cout << "The x card has a face value of ";
    cout << x.getFaceValue() << endl;

    // Set a new value and then use the accessor again
    x.setFaceValue('J');
    cout << "The x card has a face value of ";
    cout << x.getFaceValue() << endl;    

    cout << endl << endl;

    // Exploring whether our operator== function
    // is correctly working for various cases
    cout << "Exploring the operator== function uses" << endl;

    // in class we noted that was "same card" but the appropriate wording
    // is equivalent card as they are different objects with the same values

    // z and m are both default constructor creations
    // therefore we should get true here
    if (z == m)
    {
        cout << "z and m are equivalent cards" << endl;
    }
    else
    {
        cout << "z and m are NOT equivalent cards" << endl;
    }


    // x and m are both default constructor creations but x has been changed
    // therefore we should get false here
    if (x == m)
    {
        cout << "x and m are equivalent cards" << endl;
    }
    else
    {
        cout << "x and m are NOT equivalent cards" << endl;
    }


    // q and m are created with different card values, q being fully 
    // parameterized and m using the default constructor
    // therefore we should get false here
    if (q == m)
    {
        cout << "q and m are equivalent cards" << endl;
    }
    else
    {
        cout << "q and m are NOT equivalent cards" << endl;
    }

    cout << endl << endl;

    // Post Class Question & Note
    // Defining the == for our Card allows its use with Card objects
    // it does not overwrite the == operator for other data types
    cout << "Overloading the == does not impact other data types" << endl;
    int l = 2, p = 2;    
    if (l == p)
    {
        cout << "l and p integer values are the same" << endl;
    }   
}